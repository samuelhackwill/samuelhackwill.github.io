<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>index</title>
	<style>
		/* Basic styles for readability */
		body {
			font-family: sans-serif;
			max-width: 800px;
			margin: 2em auto;
			padding: 0 1em;
			line-height: 1.6;
		}
		img { max-width: 100%; height: auto; }
		pre { background-color: #f4f4f4; padding: 1em; overflow-x: auto; }
		code { font-family: monospace; }
	</style>
</head>
<body>
	<hr>
<h2>title: 60 FPS
excerpt: Dans le 10e numéro de la newsletter de Samuel Hackwill, on parle de performance informatique.
description: Dans le 10e numéro de la newsletter de Samuel Hackwill, on parle de performance informatique.
layout: single
toc: true
toc_sticky: true
og_image: /news/10/media/montage.jpeg
locale: “fr”
header: /news/10/media/montage.jpeg</h2>
<p>Chères et chers camarades,</p>
<p>c’est le dixième numéro de cette newsletter soi-disant biannuelle. Bienvenue à celleux qui nous rejoignent.</p>
<p>La dernière fois que je vous ai écrit, c’était en Septembre 2024. Je vous avait fait le compte-rendu détaillé d’une table ronde à l’Assemblée nationale où des représentants religieux ont donné leur avis au sujet du projet de loi sur la fin de vie. C’est <a href="https://samuelhackwill.github.io/news/9/#un-bouddhiste-un-musulman-un-protestant-deux-catholiques-et-un-orthodoxe-sont-%C3%A0-lassembl%C3%A9e-nationale">ici</a> si vous voulez vous y replonger. Les débats sur le projet de loi, qui avaient été interrompus par la dissolution de l’assemblée nationale, ont repris ce mois de Mai. Le texte sera voté à l’Assemblée aujourd’hui même (mardi 27 mai), et ensuite ça sera au tour du Sénat de l’examiner.</p>
<p>Mais!</p>
<p>Je n’ai pas assez parlé d’informatique la dernière fois donc, avec votre permission, parlons de code.</p>
<p><img src="/news/10/media/playsteph.png" alt="Stéphanie entourée de souris qui cliqueu cliqueu cliqueu"></p>
<h2>Tryhard</h2>
<p>Cette saison j’ai passé beaucoup de temps à programmer des ordinateurs pour <em>Tryhard</em>, ma performance pour 56 pointeurs de souris. Les premiers mois de l’année étaient particulièrement frénétiques puisque j’ai créé en Avril (le 1er). Mes ordinateurs ne m’ont pas collé un poisson dans le dos et tout s’est bien passé.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/zJ4_k_tVlSc?si=4SX-Ngzw4bncGjvN" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>Je profite d’ailleurs de l’occasion pour
1 - remercier les équipes du théâtre de l’Elysée (Lyon) qui m’ont si bien accueilli &lt;3
2 - vous inviter aux prochaines représentations de <em>Tryhard</em> qui ont lieu à <a href="https://programmation.maifsocialclub.fr/evenements/tryhard/">Paris du 19 au 21 Juin, au MAIF Social Club</a> (c’est dans le marais, rue de Turenne). Come say hi!
3- Je vais aussi jouer en “Bretagne” (à Nantes) en Décembre!</p>
<p>Écrire cette pièce était un challenge passionnant sur le plan technique et artistique. J’ai appris plein de choses. J’ai envie de partager avec vous les 3 obstacles <em>techniques</em> les plus intéressants que j’ai rencontré en cours de route, et les méthodes que j’ai mises en place pour les résoudre ou les contourner.</p>
<h2>Introduction</h2>
<p><img src="/news/10/media/crowd.jpg" alt="Le public de Tryhard, assis dans des sièges rouges et des souris sur les genoux"></p>
<p>Je me permets de reprendre du début. Tryhard, c’est une performance où je dispose 56 souris dans les gradins d’un théâtre ou d’une salle de cinéma, que le public utilise pour jouer (et le jeu, en l’occurrence, est de compléter une série de CAPTCHAs). Chaque personne est représentée à l’écran par son pointeur de souris. Nice! ou devrais-je dire, Mice! Mais comment on fait pour mettre 56 souris ensemble sur un écran?</p>
<p><img src="/news/10/media/cosmos.png" alt="Une trentaine de pointeurs dessinent un cercle parfait"></p>
<p>Vous avez peut-être déjà essayé de brancher deux souris sur un ordinateur. Non? Ok, mais si c’était le cas vous auriez constaté que ça ne fait pas apparaître un deuxième pointeur à l’écran. Et pourquoi ça? C’est simplement que les interfaces que nous utilisons n’ont pas été conçues avec le prémisse qu’on soit toute un groupe derrière son écran à interagir simultanément avec une multitude de souris. Ranger le bureau de son ordinateur n’a pas été pensé comme une activité familiale. Cliquer-glisser est un geste solitaire. Nos ordinateurs (contemporains) sont <em>personnels</em>, et les interfaces physiques que nous utilisons pour leur parler sont <em>mono-utilisateur</em> par défaut. C’est ce qui fait (pour moi) une bonne partie du charme de ce projet : j’ai pris une interface <em>single-player</em> datant des années 60 (le pointeur de souris), et je l’ai hackée pour la rendre <em>multijoueur</em>. (Je ne suis évidemment pas le premier à le faire, et mon travail se place dans la filiation de tout un courant d’expériences artistiques, sociales ou logicielles : <a href="https://en.wikipedia.org/wiki/Twitch_Plays_Pok%C3%A9mon">twitch plays pokemon</a>, <a href="https://www.google.com/search?client=safari&amp;sca_esv=7f3b3e58f08bcb9f&amp;rls=en&amp;q=figma+dev+mode&amp;tbm=nws&amp;source=lnms&amp;fbs=AIIjpHxU7SXXniUZfeShr2fp4giZ1Y6MJ25_tmWITc7uy4KIeiAkWG4OlBE2zyCTMjPbGmMYufkAHQMrNdZtNwJ4J9GCNYntnPRFCDKspCuZSigBgFj3YFbhCGG3Fh1WL1C-KtQHcz4c3qzD-9H44aKPrM7x3yYC7ZJYDwGiUipxC-dldPt0h_bLGXWAVZgSnUgKmmj6df21&amp;sa=X&amp;ved=2ahUKEwisrsOj1cCNAxVCQ6QEHRW1FxQQ0pQJegQIDhAB&amp;biw=1440&amp;bih=772&amp;dpr=2">Figma</a>, les projets du <a href="https://studiomoniker.com">studio Moniker</a> pour n’en citer que trois)</p>
<p>Partant de là, j’ai formulé tout un tas d’hypothèses plus ou moins techniques, plus ou moins chères, plus ou moins encombrantes, pour parvenir à mes fins, mais aucune n’était convaincante. J’ai fini par aboutir à la conclusion que la façon la plus simple de “brancher 56 souris ensemble” était d’utiliser une nuée de micro-ordinateurs (j’ai opté pour des raspberry pi. J’aurais probablement pu utiliser des machines moins “généralistes”, mais ça m’aurait coûté plus de recherche et de temps), connectés à un petit nombre de souris chacun (j’ai écarté l’option des souris sans fil parce que j’avais peur des interférences radio et je n’avais pas envie d’acheter 56 souris seulement pour faire un test grandeur nature, mais who knows peut être que c’est une solution crédible!), et reliés entre eux par “internet” (c’est à dire avec le protocole TCP/IP, des câbles RJ45, un routeur et un switch). C’est ça le dispositif de Tryhard!</p>
<p>Enfin, il faut ajouter encore deux machines : mon laptop qui joue le rôle de serveur (les micro-ordinateurs dans la salle lui retransmettent le signal des souris), sur lequel tourne une application web qui a pour fonction de simuler une nuée de “pointeurs de souris” sur une page web, et un vidéoprojecteur qui vidéoprojecte tout ça sur grand écran. Je dis “pointeurs de souris” entre guillemets, parce qu’en fait ce sont de vulgaires <code>&lt;div&gt;</code> avec une image de pointeur de souris en <code>background-image</code>, pour ceux à qui ça parle. Ce ne sont pas de <em>vrais</em> pointeurs de souris, ou on pourrait dire, des pointeurs de souris <em>natifs</em>. Ce sont des frankenstein de pointeurs de souris, un agglomérat putréfié de code et de pixels exhibant artificiellement des comportements proches de ceux d’un pointeur de souris normal. Ce qui a des conséquences pratiques, on y reviendra dans la dernière partie sur le <em>jank</em>.</p>
<h2>Problème n°1 : la latence</h2>
<p>Je suis donc arrivé a une sorte de sandwich technique dont chaque couche apporte un peu de complexité supplémentaire. Mon inquiétude était que quand on bouge la souris, tout ce beau monde ait besoin de trop de temps pour réfléchir, et que ce soit perceptible visuellement. Enfin, mon objectif n’était pas que la latence soit tout à fait invisible (pour cela il aurait fallu qu’elle soit inférieure à 20 millisecondes), mais qu’elle soit suffisamment faible pour ne pas être désagréable, disons, anything en-dessous de 200ms.</p>
<p>Je n’ai pas réussi à retrouver une bonne vidéo des distributeurs de billets SNCF pour donner un exemple de latence désagréable ; j’ai seulement trouvé cette vidéo intitulée <a href="https://www.youtube.com/watch?v=zQrNUwgvvfM&amp;ab_channel=R%C3%A9gionAuvergne-Rh%C3%B4ne-Alpes">“J’achète mon billet à un distributeur automatique”</a> où la machine fonctionne inhabituellement bien. On voit tout de même que lorsque l’utilisateur CLiQuE de toutes ses forces, l’ordinateur ne donne aucune indiction qu’il a bien pris en compte le clic : une à deux secondes de latence s’écoulent “silencieusement” avant que le menu suivant s’affiche. Not ideal. Néanmoins, je peux vous dire que le distributeur de billets qui est resté au soleil et à la pluie tous les jours de sa vie en gare de <em>LÉPIN-LE-LAC LA BAUCHE</em> exhibait facilement une latence de 2000 à 3000ms entre le moment où on tournait la tournette et une réaction de sa part, qu’on puisse enfin sélectionner <em>CHAMBÉRY-CHALLES LES EAUX</em> dans le menu, bon sang de bois, et voilà le train qui arrive en gare et on va rater le train à cause de cette maudite machine qui a certes pris la pluie pendant des années mais faillit maintenant à son devoir de service public.</p>
<p>Mon but était éventuellement de faire mieux que le distributeur de billets de la gare de Lépin, et qu’il n’y ait pas une latence de 3000ms entre un mouvement de souris et sa répercussion à l’écran. Quand j’ai fait le tout premier prototype de Tryhard, j’ai constaté visuellement que la latence était tout à fait raisonnable (contre toute attente), alors je suis tout simplement passé à autre chose.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/8Z8ORJYKFIU?si=jpboFxB_bpGyMVVj" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>Le stack (c’est à dire ce qu’on a appelé tout à l’heure “sandwich technique”) était biennnn différent à cette époque, j’ai tout réécrit depuis. Vous pouvez checker cette conversation <a href="https://github.com/function61/screen-server/discussions/10">ici</a> si vous savoir comment j’ai fabriqué le tout premier prototype, avec l’aide d’un développeur Finlandais et de mon ami Etienne Boutin, qui est dev également.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/Cqm0_0RljFg?si=Jp-SbneHYh9f22H8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>J’ai essayé de mesurer la latence approximative qu’il y a dans Tryhard (la version actuelle), de la manière suivante : j’ai filmé mon écran au ralenti avec mon téléphone (240 images / seconde), et j’ai utilisé <a href="https://fr.wikipedia.org/wiki/FFmpeg">ffmpeg</a> pour décomposer la vidéo en fichiers jpeg, 1 image / frame. J’ai ensuite compté les images avec les doigts de ma main entre le moment où je frappe ma souris et le moment où le pointeur se décide à bouger (j’ai compté 28 frames, donc ça fait une latence de 28 x (1000/240) = ~104 ms). Not <em>that</em> bad.</p>
<p>C’est une latence parfaitement acceptable pour mes besoins. Elle est perceptible, mais en réalité le plus important pour un jeu où on a besoin de bouger rapidement son curseur dans un espace 2D, c’est que la latence soit <em>constante</em> et donc <em>prévisible</em>. Il vaut mieux qu’il y ait un peu de latence tout le temps mais sans grande variation, que très peu de latence most of the time avec des gros pics intempestifs. C’est la définition même du deuxième grand méchant problème informatique que j’ai rencontré : le jitter.</p>
<h2>Problème n°2 : le jitter</h2>
<p>La première fois que j’ai fait un test en conditions réelles avec 14 raspberry pi répartis dans les gradins du cinéma Méliès, à Villeneuve-d’Ascq, avec une quarantaine d’humains au bout de leurs souris, j’ai rencontré un problème plutôt inquiétant : il y avait manifestement une très forte variation de latence dans le déplacement des pointeurs à l’écran. On le voit dans ces deux vidéos, tournées par Julie Holin qui m’a filé la main sur cette résidence (merci Julie!) :</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/X1CXLbgvw9A?si=3017jopQsZIPCSTL" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>ci-dessus j’ai mis une tite flèche rouge à côté d’un curseur particulièrement jittery (APA). Au lieu de se déplacer avec souplesse d’un point à un autre, il “saute” ; sa position n’est pas mise à jour 60 fois par seconde comme on aimerait, mais dans ce cas, 3 ou 4 fois maximum, gloups.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/M6oVb8VxIsw?si=t9gcmfeq4j4JnqP8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>ci-dessus j’ai mis une tite flèche à côté d’un autre curseur (EMO), pour qui tout se passe plutôt bien initialement, mais à un moment il semble tétanisé, avant de sauter subitement à une autre position. C’est ça le jitter.</p>
<p>La majorité des pointeurs ont un comportement saccadé. Cette fois-ci on ne parle pas seulement d’un problème qui est désagréable, mais qui rend tout à fait impossible de repérer et de suivre son curseur à l’écran. J’étais obligé de résoudre ce problème si je voulais qu’il y ait un moment dans la performance où tout le monde joue ensemble.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/dd-tWj8EB-c?si=aNuHfIR-uX5kArK6" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>Dans la mesure où je ne pouvais pas séquestrer le public pendant un mois pour tester et modifier le système avec elleux, j’ai dû mettre en place un environnement de test automatisé pour comprendre d’où ces variations de latence venaient. Dans la vidéo on voit le <em>jitter</em> en action : certains curseurs font subitement une sorte de pause pendant que d’autres ont un déplacement fluide. Quand j’ai vu ça j’étais à la fois content (youpi j’ai réussi à répliquer le bug!) et dubitatif (pourquoi y’en a qui sont en bonne santé mais pas les autres alors que c’est le même code, les mêmes ordinateurs, les mêmes souris? huUuhH)</p>
<p>Long story short, le <em>jitter</em> survenait parce que les raspberry étaient connectés ensemble en wi-fi, que j’utilisais un pauvre routeur sans antenne posé dans le fond de la salle, et que les corps humains dans la salle, qu’il faut considérer comme des gros sacs d’eau, ne sont pas gentils avec les ondes wifi (ils les bloquent). Les micro-ordinateurs répartis dans la salle avaient donc du mal a maintenir une connection stable avec le serveur, à part celui qui était juste à côté du routeur, ce qui explique pourquoi <em>quelques</em> curseurs à l’écran ont un déplacement parfaitement fluide.</p>
<p>J’ai donc mis tous les rasps en connection filaire et le problème était 100% réglé. J’ai poussé un très gros soupir de soulagement parce qu’à l’époque j’étais convaincu à tort que le jitter était causé par le protocole de communication que j’utilisais entre les raspberry (<em>WebSockets</em>), et je n’avais pas du tout envie de taper dans la gamme au-dessus parce que les protocoles plus rapides que j’avais en tête sont compliqués (une personne m’a dit un jour à leur sujet : “attention, il faut savoir compiler du C”). Or je ne sais pas compiler du C, moi. Que la personne qui a déjà compilé du C me jette la première pierre.</p>
<h2>Problème n°3 : le jank</h2>
<p>Le dernier problème que j’ai rencontré est arrivé assez tard dans le projet. Je travaillais sur une séquence où chaque souris pouvait enfanter de nouvelles souris, saturant progressivement l’écran avec plein de petites souris. Ça n’a l’air de rien mais c’était beaucoup trop violent pour le navigateur web! Ou plutôt, c’était violent parce que c’était <em>codé</em> d’une certaine façon qui n’était pas nécessairement optimisée. J’ai observé un ralentissement du framerate, c’est à dire que toutes les animations devenaient saccadées et pas fluides.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/tAeU1XIyIP8?si=C0JLlOEYWCuM64Pz" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
Là il n'y a pas de problème parce que je fais ça tout seul dans mon coin ; mais quand je l'ai fait en live pendant une sortie de résidence avec une vingtaine de personnes ça a tout pété
<p>Ce phénomène survient parce que tout programme voulant afficher des choses sur un écran dispose d’un budget de 16,66 millisecondes pour faire tous ses calculs (si on veut que ça soit fluide et good-looking. Enfin, “fluide” dans la mesure où ce programme est affiché par un vidéoprojecteur ou un moniteur 60Hz, qui produit donc 60 images par seconde. Le budget est encore plus réduit si on désire produire des effets visuels au maximum des capacités d’affichage d’un moniteur 240Hz, qui produit 240 images par seconde).</p>
<p>Quand les calculs prennent plus de temps que 16,66 millisecondes, il vont bloquer l’affichage pendant 1 frame, ce qui veut dire que le navigateur produit maintenant 59 images / secondes, sniff. Si cette situation se répète ou que des calculs bloquent l’affichage pendant plusieurs frames, l’image peut devenir saccadée. En fait c’est exactement le même symptôme que le jitter, mais qui a des causes différentes! (Dans le cas du jitter, c’est la connection qui bug, alors que dans le cas qu’on est en train de décrire, il s’agit plutôt d’une surcharge des capacités de calcul de l’ordinateur). Levez la main si vous aimez les ordinateurs.</p>
<p><img src="/news/10/media/fps.png" alt="Dev Tools">
<em>ici j’étais en train d’auditer une séquence assez chère en calculs où je fais tomber plein de CAPTCHAs du ciel. Toutes les petites barres en bas représentent le temps mis pour exécuter une fonction, une partie du code.</em></p>
<p>J’ai utilisé les outils de Google Chrome pour auditer mon code et essayer de comprendre si j’avais de la marge de manoeuvre pour le rendre plus efficace. Dans Chrome, on peut enregistrer une session de navigation, et exporter les données brutes au format json (c’est une sorte de gros fichier texte). J’ai collé ce fichier dans <em>gloups</em> chatGPT pour ébaucher des pistes sur quelles pouvaient potentiellement être les parties les plus gourmandes en calculs de mon programme. J’ai alors entrepris plusieurs optimisations, mais les gains en performance n’étaient pas suffisants et j’ai dû abandonner cette séquence (pour obtenir une amélioration suffisante il aurait fallu entièrement reprendre la base de code à partir de zéro, en utilisant d’autres langages et une logique toute autre).</p>
<p>Ce n’est pas difficile en soi pour un ordinateur d’afficher plein de souris qui bougent. Je pourrais faire une vidéo avec des millions de souris qui bougent, et hop l’ordinateur pourrait l’afficher sans problème. Là, le problème, c’est que ce ne sont pas juste des <em>images</em> de souris qui bougent, mais que ce sont des systèmes réactifs qui peuvent <em>faire des choses</em> et qui <em>obéissent</em> à un flux de données, ce qui est plus lourd en terme de calculs. Par ailleurs, j’utilise un outil très généraliste (le navigateur web) et des langages mal adaptés (javascript, html &amp; css) pour les effets visuels.</p>
<p>La raison pour laquelle j’ai choisi cette approche in the first place, c’est que comme ma pièce parle des CAPTCHAs, qui sont réalisés avec les mêmes langages, j’ai pu prototyper très rapidement mes premières séquences ; c’était une bonne approche tant que je faisais pas trop des trucs de malades avec mes pointeurs de souris et les cases à cocher des CAPTCHAs. Mais plus j’avais envie d’expérimenter avec la gravité, la collision, ou des effets visuels plus lourds, plus mes choix technologiques du début me tiraient en arrière.</p>
<h2>Conclusion</h2>
<p>Comme souvent en informatique, il n’y a pas de solution parfaite, mais des compromis ; il faut trouver un équilibre entre complexité du code, lisibilité du code, rapidité de mise en oeuvre, et performance. C’est aussi pour ça qu’on se retrouve régulièrement à tout réécrire, ou réécrire une partie de son code ; à mesure que la situation change, les paramètres de l’équation de déplacent et modifient la “désirabilité” d’une option.</p>
<p>C’est tout pour cette fois!</p>
<p>Je profite de l’occasion pour remercier <a href="https://www.instagram.com/stephanie.aflalo">Stéphanie Aflalo</a>, qui m’a accompagné tout au long de l’écriture de la pièce, Étienne Boutin, qui m’a donné le courage de faire le premier prototype, et Diane Landais, qui a écrit une partie de la base de code, m’a conseillé et épaulé face aux 3 problèmes.</p>
<p>&lt;3 &lt;3 &lt;3</p>

</body>
</html>